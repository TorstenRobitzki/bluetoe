<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BlueToe: bluetoe::link_layer::scheduled_radio&lt; TransmitSize, ReceiveSize, CallBack &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Logo_Bluetoe.svg"/></td>
  <td id="projectalign">
   <div id="projectname">BlueToe
   </div>
   <div id="projectbrief">an alternative GATT/BLE implementation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bluetoe</b></li><li class="navelem"><b>link_layer</b></li><li class="navelem"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">scheduled_radio</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classbluetoe_1_1link__layer_1_1scheduled__radio-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">bluetoe::link_layer::scheduled_radio&lt; TransmitSize, ReceiveSize, CallBack &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Type responsible for radio I/O and timing.  
 <a href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="scheduled__radio_8hpp_source.html">bluetoe/link_layer/scheduled_radio.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bluetoe::link_layer::scheduled_radio&lt; TransmitSize, ReceiveSize, CallBack &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbluetoe_1_1link__layer_1_1scheduled__radio.png" usemap="#bluetoe::link_5Flayer::scheduled_5Fradio_3C_20TransmitSize_2C_20ReceiveSize_2C_20CallBack_20_3E_map" alt=""/>
  <map id="bluetoe::link_5Flayer::scheduled_5Fradio_3C_20TransmitSize_2C_20ReceiveSize_2C_20CallBack_20_3E_map" name="bluetoe::link_5Flayer::scheduled_5Fradio_3C_20TransmitSize_2C_20ReceiveSize_2C_20CallBack_20_3E_map">
<area href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html" alt="bluetoe::link_layer::ll_data_pdu_buffer&lt; TransmitSize, ReceiveSize, scheduled_radio&lt; TransmitSize, ReceiveSize, CallBack &gt; &gt;" shape="rect" coords="0,0,736,24"/>
<area href="classbluetoe_1_1link__layer_1_1scheduled__radio__with__encryption.html" title="extension of a scheduled_radio with functions to support encryption" alt="bluetoe::link_layer::scheduled_radio_with_encryption&lt; TransmitSize, ReceiveSize, CallBack &gt;" shape="rect" coords="0,112,736,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acaba4a41d5452cb8e33e209b3e7dde4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#acaba4a41d5452cb8e33e209b3e7dde4b">scheduled_radio</a> ()</td></tr>
<tr class="separator:acaba4a41d5452cb8e33e209b3e7dde4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e6ef1abf22e324765a0dfd245a6ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#af7e6ef1abf22e324765a0dfd245a6ed2">schedule_advertisment</a> (unsigned channel, const <a class="el" href="structbluetoe_1_1link__layer_1_1write__buffer.html">bluetoe::link_layer::write_buffer</a> &amp;advertising_data, const <a class="el" href="structbluetoe_1_1link__layer_1_1write__buffer.html">bluetoe::link_layer::write_buffer</a> &amp;response_data, <a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a> when, const <a class="el" href="structbluetoe_1_1link__layer_1_1read__buffer.html">bluetoe::link_layer::read_buffer</a> &amp;receive)</td></tr>
<tr class="memdesc:af7e6ef1abf22e324765a0dfd245a6ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">schedules for transmission of advertising data and starts to receive 150Âµs later  <br /></td></tr>
<tr class="separator:af7e6ef1abf22e324765a0dfd245a6ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30836f45d87614c8d0b30c08c067b73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#af30836f45d87614c8d0b30c08c067b73">schedule_connection_event</a> (unsigned channel, <a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a> start_receive, <a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a> end_receive, <a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a> connection_interval)</td></tr>
<tr class="memdesc:af30836f45d87614c8d0b30c08c067b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">schedules a connection event  <br /></td></tr>
<tr class="separator:af30836f45d87614c8d0b30c08c067b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac252a72ef11c7512ec918764d25c81ec"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#ac252a72ef11c7512ec918764d25c81ec">disarm_connection_event</a> ()</td></tr>
<tr class="memdesc:ac252a72ef11c7512ec918764d25c81ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">tries to stop a scheduled connection event  <br /></td></tr>
<tr class="separator:ac252a72ef11c7512ec918764d25c81ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06f311e5b863235bbffe431c9236dc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#ab06f311e5b863235bbffe431c9236dc0">schedule_synchronized_user_timer</a> (<a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a> timeout, <a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a> max_cb_runtime)</td></tr>
<tr class="memdesc:ab06f311e5b863235bbffe431c9236dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets up a timer  <br /></td></tr>
<tr class="separator:ab06f311e5b863235bbffe431c9236dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eabb58c77af8a57c44edc7adcbe959"><td class="memItemLeft" align="right" valign="top"><a id="a08eabb58c77af8a57c44edc7adcbe959" name="a08eabb58c77af8a57c44edc7adcbe959"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cancel_synchronized_user_timer</b> ()</td></tr>
<tr class="memdesc:a08eabb58c77af8a57c44edc7adcbe959"><td class="mdescLeft">&#160;</td><td class="mdescRight">cancel the user timer <br /></td></tr>
<tr class="separator:a08eabb58c77af8a57c44edc7adcbe959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bd3a35173bb9ea31b295fbfd2a3823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a02bd3a35173bb9ea31b295fbfd2a3823">set_access_address_and_crc_init</a> (std::uint32_t access_address, std::uint32_t crc_init)</td></tr>
<tr class="memdesc:a02bd3a35173bb9ea31b295fbfd2a3823"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the access address initial CRC value for transmitted and received PDU  <br /></td></tr>
<tr class="separator:a02bd3a35173bb9ea31b295fbfd2a3823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7c8ff0e257a8e7d68462c408aa6523"><td class="memItemLeft" align="right" valign="top"><a id="abd7c8ff0e257a8e7d68462c408aa6523" name="abd7c8ff0e257a8e7d68462c408aa6523"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>static_random_address_seed</b> () const</td></tr>
<tr class="memdesc:abd7c8ff0e257a8e7d68462c408aa6523"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to return a device specific value that is persistent and unique for the device (CPU id or such) <br /></td></tr>
<tr class="separator:abd7c8ff0e257a8e7d68462c408aa6523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17adbfc6e6022ac5f04aa3fe26b4d85a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a17adbfc6e6022ac5f04aa3fe26b4d85a">run</a> ()</td></tr>
<tr class="memdesc:a17adbfc6e6022ac5f04aa3fe26b4d85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates the CPU to the <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html" title="Type responsible for radio I/O and timing.">scheduled_radio</a>  <br /></td></tr>
<tr class="separator:a17adbfc6e6022ac5f04aa3fe26b4d85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fb3007179d5653da9b360c4762f49f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#ab9fb3007179d5653da9b360c4762f49f">wake_up</a> ()</td></tr>
<tr class="memdesc:ab9fb3007179d5653da9b360c4762f49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">forces the <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a17adbfc6e6022ac5f04aa3fe26b4d85a" title="allocates the CPU to the scheduled_radio">run()</a> function to return at least once  <br /></td></tr>
<tr class="separator:ab9fb3007179d5653da9b360c4762f49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8cf474398a43df21d714de449e17ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a7d8cf474398a43df21d714de449e17ec">request_event_cancelation</a> ()</td></tr>
<tr class="memdesc:a7d8cf474398a43df21d714de449e17ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">forces the call of CallBack::try_event_cancelation() from the context of the <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a17adbfc6e6022ac5f04aa3fe26b4d85a" title="allocates the CPU to the scheduled_radio">run()</a> function  <br /></td></tr>
<tr class="separator:a7d8cf474398a43df21d714de449e17ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3f65c5438fda40cc43054a55a180ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a2d3f65c5438fda40cc43054a55a180ea">radio_add_to_white_list</a> (const <a class="el" href="classbluetoe_1_1link__layer_1_1device__address.html">device_address</a> &amp;addr)</td></tr>
<tr class="memdesc:a2d3f65c5438fda40cc43054a55a180ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">add the given address to the white list.  <br /></td></tr>
<tr class="separator:a2d3f65c5438fda40cc43054a55a180ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6202ff7f79e51402383ff6290f30677"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#ae6202ff7f79e51402383ff6290f30677">radio_remove_from_white_list</a> (const <a class="el" href="classbluetoe_1_1link__layer_1_1device__address.html">device_address</a> &amp;addr)</td></tr>
<tr class="memdesc:ae6202ff7f79e51402383ff6290f30677"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the given address from the white list  <br /></td></tr>
<tr class="separator:ae6202ff7f79e51402383ff6290f30677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc03e6b5314c287d369bd17d0b2090c"><td class="memItemLeft" align="right" valign="top"><a id="adfc03e6b5314c287d369bd17d0b2090c" name="adfc03e6b5314c287d369bd17d0b2090c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>radio_is_in_white_list</b> (const <a class="el" href="classbluetoe_1_1link__layer_1_1device__address.html">device_address</a> &amp;addr) const</td></tr>
<tr class="memdesc:adfc03e6b5314c287d369bd17d0b2090c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, if the given address in within the white list <br /></td></tr>
<tr class="separator:adfc03e6b5314c287d369bd17d0b2090c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bee055c7eca2727f924938cbafbde97"><td class="memItemLeft" align="right" valign="top"><a id="a2bee055c7eca2727f924938cbafbde97" name="a2bee055c7eca2727f924938cbafbde97"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>radio_white_list_free_size</b> () const</td></tr>
<tr class="memdesc:a2bee055c7eca2727f924938cbafbde97"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of addresses that could be added to the white list before add_to_white_list() would return false. <br /></td></tr>
<tr class="separator:a2bee055c7eca2727f924938cbafbde97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb6a39dc3d569154979cd10dd176f35"><td class="memItemLeft" align="right" valign="top"><a id="abcb6a39dc3d569154979cd10dd176f35" name="abcb6a39dc3d569154979cd10dd176f35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>radio_clear_white_list</b> ()</td></tr>
<tr class="memdesc:abcb6a39dc3d569154979cd10dd176f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all entries from the white list <br /></td></tr>
<tr class="separator:abcb6a39dc3d569154979cd10dd176f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7ff277ad07969c5387fe7524367bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#aed7ff277ad07969c5387fe7524367bb6">connection_request_filter</a> (bool b)</td></tr>
<tr class="memdesc:aed7ff277ad07969c5387fe7524367bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept connection requests only from devices within the white list.  <br /></td></tr>
<tr class="separator:aed7ff277ad07969c5387fe7524367bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cefde9648a6a3aa598c18d98f538dec"><td class="memItemLeft" align="right" valign="top"><a id="a4cefde9648a6a3aa598c18d98f538dec" name="a4cefde9648a6a3aa598c18d98f538dec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>connection_request_filter</b> () const</td></tr>
<tr class="memdesc:a4cefde9648a6a3aa598c18d98f538dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">current value of the property. <br /></td></tr>
<tr class="separator:a4cefde9648a6a3aa598c18d98f538dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4fd25ab8ea1ff8f4eacdba75eda520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#abd4fd25ab8ea1ff8f4eacdba75eda520">radio_scan_request_filter</a> (bool b)</td></tr>
<tr class="memdesc:abd4fd25ab8ea1ff8f4eacdba75eda520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept scan requests only from devices within the white list.  <br /></td></tr>
<tr class="separator:abd4fd25ab8ea1ff8f4eacdba75eda520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcbb83c0e97885ff54d9037d1d0c96c"><td class="memItemLeft" align="right" valign="top"><a id="afbcbb83c0e97885ff54d9037d1d0c96c" name="afbcbb83c0e97885ff54d9037d1d0c96c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>radio_scan_request_filter</b> () const</td></tr>
<tr class="memdesc:afbcbb83c0e97885ff54d9037d1d0c96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">current value of the property. <br /></td></tr>
<tr class="separator:afbcbb83c0e97885ff54d9037d1d0c96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39c616d23caf66fbfa48b8f30bfc882"><td class="memItemLeft" align="right" valign="top"><a id="aa39c616d23caf66fbfa48b8f30bfc882" name="aa39c616d23caf66fbfa48b8f30bfc882"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>radio_is_connection_request_in_filter</b> (const <a class="el" href="classbluetoe_1_1link__layer_1_1device__address.html">device_address</a> &amp;addr) const</td></tr>
<tr class="memdesc:aa39c616d23caf66fbfa48b8f30bfc882"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, if a connection request from the given address should be answered. <br /></td></tr>
<tr class="separator:aa39c616d23caf66fbfa48b8f30bfc882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb35e58bc9e500d16c931f005389cc56"><td class="memItemLeft" align="right" valign="top"><a id="aeb35e58bc9e500d16c931f005389cc56" name="aeb35e58bc9e500d16c931f005389cc56"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>radio_is_scan_request_in_filter</b> (const <a class="el" href="classbluetoe_1_1link__layer_1_1device__address.html">device_address</a> &amp;addr) const</td></tr>
<tr class="memdesc:aeb35e58bc9e500d16c931f005389cc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, if a scan request from the given address should be answered. <br /></td></tr>
<tr class="separator:aeb35e58bc9e500d16c931f005389cc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006fb1ad6ba509dd08e0dd08caba6663"><td class="memItemLeft" align="right" valign="top"><a id="a006fb1ad6ba509dd08e0dd08caba6663" name="a006fb1ad6ba509dd08e0dd08caba6663"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>radio_set_phy</b> (details::phy_ll_encoding receiving_encoding, details::phy_ll_encoding transmiting_c_encoding)</td></tr>
<tr class="memdesc:a006fb1ad6ba509dd08e0dd08caba6663"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the used PHY encoding for the transmitting and receiving side <br /></td></tr>
<tr class="separator:a006fb1ad6ba509dd08e0dd08caba6663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html">bluetoe::link_layer::ll_data_pdu_buffer&lt; TransmitSize, ReceiveSize, scheduled_radio&lt; TransmitSize, ReceiveSize, CallBack &gt; &gt;</a></td></tr>
<tr class="memitem:a58a5626d5702e9ee528f15d854df6556 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a58a5626d5702e9ee528f15d854df6556">ll_data_pdu_buffer</a> ()</td></tr>
<tr class="separator:a58a5626d5702e9ee528f15d854df6556 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244e1428b03a4afa51c1aabaf96cbb98 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a244e1428b03a4afa51c1aabaf96cbb98">max_max_rx_size</a> () const</td></tr>
<tr class="memdesc:a244e1428b03a4afa51c1aabaf96cbb98 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum value that can be used as maximum receive size.  <br /></td></tr>
<tr class="separator:a244e1428b03a4afa51c1aabaf96cbb98 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e4c3fef3ba2586bf4fee4cc4821642 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#ac3e4c3fef3ba2586bf4fee4cc4821642">max_rx_size</a> () const</td></tr>
<tr class="memdesc:ac3e4c3fef3ba2586bf4fee4cc4821642 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the current maximum receive size  <br /></td></tr>
<tr class="separator:ac3e4c3fef3ba2586bf4fee4cc4821642 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3c5b1fcefca3b37ba849d471e2fb0a inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a5b3c5b1fcefca3b37ba849d471e2fb0a">max_rx_size</a> (std::size_t max_size)</td></tr>
<tr class="memdesc:a5b3c5b1fcefca3b37ba849d471e2fb0a inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the maximum receive size  <br /></td></tr>
<tr class="separator:a5b3c5b1fcefca3b37ba849d471e2fb0a inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2389e39e39ea1f0138b1926e4070be0 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#ab2389e39e39ea1f0138b1926e4070be0">max_max_tx_size</a> () const</td></tr>
<tr class="memdesc:ab2389e39e39ea1f0138b1926e4070be0 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum value that can be used as maximum receive size.  <br /></td></tr>
<tr class="separator:ab2389e39e39ea1f0138b1926e4070be0 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94b2fe5f1f25232a7479e3c8c82d043 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#af94b2fe5f1f25232a7479e3c8c82d043">max_tx_size</a> () const</td></tr>
<tr class="memdesc:af94b2fe5f1f25232a7479e3c8c82d043 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the current maximum transmit size  <br /></td></tr>
<tr class="separator:af94b2fe5f1f25232a7479e3c8c82d043 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904e1fc0e76ccd818e8cff85a8790064 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a904e1fc0e76ccd818e8cff85a8790064">max_tx_size</a> (std::size_t max_size)</td></tr>
<tr class="memdesc:a904e1fc0e76ccd818e8cff85a8790064 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the maximum transmit size  <br /></td></tr>
<tr class="separator:a904e1fc0e76ccd818e8cff85a8790064 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52221aced6f878937934956c5150f1a inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">std::uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#ad52221aced6f878937934956c5150f1a">raw_pdu_buffer</a> ()</td></tr>
<tr class="memdesc:ad52221aced6f878937934956c5150f1a inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the underlying raw buffer with a size of at least <a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a875552bde9322f3d07ad9e9a9dc90a30" title="the size of memory in bytes that are return by raw()">ll_data_pdu_buffer::size</a>  <br /></td></tr>
<tr class="separator:ad52221aced6f878937934956c5150f1a inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdecc4048b47f32beaad62080326968 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a2cdecc4048b47f32beaad62080326968">stop_pdu_buffer</a> ()</td></tr>
<tr class="memdesc:a2cdecc4048b47f32beaad62080326968 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">places the buffer in stopped mode.  <br /></td></tr>
<tr class="separator:a2cdecc4048b47f32beaad62080326968 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a3d5e8b3b8c2a8cd2525620ab9a124 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#ad3a3d5e8b3b8c2a8cd2525620ab9a124">reset_pdu_buffer</a> ()</td></tr>
<tr class="memdesc:ad3a3d5e8b3b8c2a8cd2525620ab9a124 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">places the buffer in running mode.  <br /></td></tr>
<tr class="separator:ad3a3d5e8b3b8c2a8cd2525620ab9a124 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02afffdc3c6fafc155fc2cfffa71fa28 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbluetoe_1_1link__layer_1_1read__buffer.html">read_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a02afffdc3c6fafc155fc2cfffa71fa28">allocate_transmit_buffer</a> (std::size_t size)</td></tr>
<tr class="memdesc:a02afffdc3c6fafc155fc2cfffa71fa28 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a certain amount of memory to place a PDU to be transmitted .  <br /></td></tr>
<tr class="separator:a02afffdc3c6fafc155fc2cfffa71fa28 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddf12541649a13a98724c36c4672b7b inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a id="aeddf12541649a13a98724c36c4672b7b" name="aeddf12541649a13a98724c36c4672b7b"></a>
<a class="el" href="structbluetoe_1_1link__layer_1_1read__buffer.html">read_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>allocate_transmit_buffer</b> ()</td></tr>
<tr class="memdesc:aeddf12541649a13a98724c36c4672b7b inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls allocate_transmit_buffer( <a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#af94b2fe5f1f25232a7479e3c8c82d043" title="the current maximum transmit size">max_tx_size()</a> + layout_overhead ); <br /></td></tr>
<tr class="separator:aeddf12541649a13a98724c36c4672b7b inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b12c9254634104dfef838a81e40869 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a24b12c9254634104dfef838a81e40869">commit_transmit_buffer</a> (<a class="el" href="structbluetoe_1_1link__layer_1_1read__buffer.html">read_buffer</a>)</td></tr>
<tr class="memdesc:a24b12c9254634104dfef838a81e40869 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates that prior allocated memory is now ready for transmission  <br /></td></tr>
<tr class="separator:a24b12c9254634104dfef838a81e40869 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f47761c0b91e2e18654429994e4f80 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a id="a83f47761c0b91e2e18654429994e4f80" name="a83f47761c0b91e2e18654429994e4f80"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pending_outgoing_data_available</b> () const</td></tr>
<tr class="memdesc:a83f47761c0b91e2e18654429994e4f80 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, if there is pending, outgoing data <br /></td></tr>
<tr class="separator:a83f47761c0b91e2e18654429994e4f80 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2622bd60da7022ce36d27f080d1c18ea inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbluetoe_1_1link__layer_1_1write__buffer.html">write_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a2622bd60da7022ce36d27f080d1c18ea">next_received</a> () const</td></tr>
<tr class="memdesc:a2622bd60da7022ce36d27f080d1c18ea inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the oldest PDU out of the receive buffer.  <br /></td></tr>
<tr class="separator:a2622bd60da7022ce36d27f080d1c18ea inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ca705319b23860aeabe4d6d19bd6e0 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#ae8ca705319b23860aeabe4d6d19bd6e0">free_received</a> ()</td></tr>
<tr class="memdesc:ae8ca705319b23860aeabe4d6d19bd6e0 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the oldest PDU from the receive buffer.  <br /></td></tr>
<tr class="separator:ae8ca705319b23860aeabe4d6d19bd6e0 inherit pub_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9bcf918b88aceffc880ce2049ede5947"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a9bcf918b88aceffc880ce2049ede5947">radio_maximum_white_list_entries</a> = 4</td></tr>
<tr class="memdesc:a9bcf918b88aceffc880ce2049ede5947"><td class="mdescLeft">&#160;</td><td class="mdescRight">giving the maximum number of white list entries, the scheduled radio supports by hardware  <br /></td></tr>
<tr class="separator:a9bcf918b88aceffc880ce2049ede5947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05028ea1473d2778024d1e7d155504ad"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a05028ea1473d2778024d1e7d155504ad">radio_package_overhead</a> = 0</td></tr>
<tr class="memdesc:a05028ea1473d2778024d1e7d155504ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">a number of bytes that are additional required by the hardware to handle an over the air package/PDU.  <br /></td></tr>
<tr class="separator:a05028ea1473d2778024d1e7d155504ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73130b992b4a65be0e762e7fbfa81463"><td class="memItemLeft" align="right" valign="top"><a id="a73130b992b4a65be0e762e7fbfa81463" name="a73130b992b4a65be0e762e7fbfa81463"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hardware_supports_encryption</b> = false</td></tr>
<tr class="memdesc:a73130b992b4a65be0e762e7fbfa81463"><td class="mdescLeft">&#160;</td><td class="mdescRight">indication no support for encryption <br /></td></tr>
<tr class="separator:a73130b992b4a65be0e762e7fbfa81463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eaf4f6a4c9b749650debadb19ef7c7"><td class="memItemLeft" align="right" valign="top"><a id="ab5eaf4f6a4c9b749650debadb19ef7c7" name="ab5eaf4f6a4c9b749650debadb19ef7c7"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hardware_supports_2mbit</b> = true</td></tr>
<tr class="memdesc:ab5eaf4f6a4c9b749650debadb19ef7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates support for 2Mbit <br /></td></tr>
<tr class="separator:ab5eaf4f6a4c9b749650debadb19ef7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9514e59ec90ae576ab356d4392dc75d8"><td class="memItemLeft" align="right" valign="top"><a id="a9514e59ec90ae576ab356d4392dc75d8" name="a9514e59ec90ae576ab356d4392dc75d8"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hardware_supports_synchronized_user_timer</b> = true</td></tr>
<tr class="memdesc:a9514e59ec90ae576ab356d4392dc75d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates support for <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#ab06f311e5b863235bbffe431c9236dc0" title="sets up a timer">schedule_synchronized_user_timer()</a> <br /></td></tr>
<tr class="separator:a9514e59ec90ae576ab356d4392dc75d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html">bluetoe::link_layer::ll_data_pdu_buffer&lt; TransmitSize, ReceiveSize, scheduled_radio&lt; TransmitSize, ReceiveSize, CallBack &gt; &gt;</a></td></tr>
<tr class="memitem:a875552bde9322f3d07ad9e9a9dc90a30 inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a id="a875552bde9322f3d07ad9e9a9dc90a30" name="a875552bde9322f3d07ad9e9a9dc90a30"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b></td></tr>
<tr class="memdesc:a875552bde9322f3d07ad9e9a9dc90a30 inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the size of memory in bytes that are return by raw() <br /></td></tr>
<tr class="separator:a875552bde9322f3d07ad9e9a9dc90a30 inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a15afdc2b6e3e24e7ac6b290f7aa9e inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a id="a94a15afdc2b6e3e24e7ac6b290f7aa9e" name="a94a15afdc2b6e3e24e7ac6b290f7aa9e"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>min_buffer_size</b></td></tr>
<tr class="memdesc:a94a15afdc2b6e3e24e7ac6b290f7aa9e inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the minimum size an element in the buffer can have (header size + payload size). <br /></td></tr>
<tr class="separator:a94a15afdc2b6e3e24e7ac6b290f7aa9e inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887d0f88c0023077cf456fd0fc5722e2 inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a id="a887d0f88c0023077cf456fd0fc5722e2" name="a887d0f88c0023077cf456fd0fc5722e2"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_buffer_size</b></td></tr>
<tr class="memdesc:a887d0f88c0023077cf456fd0fc5722e2 inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the maximum size an element in the buffer can have (header size + payload size). <br /></td></tr>
<tr class="separator:a887d0f88c0023077cf456fd0fc5722e2 inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9a1b299b4901f8ec5c17a495ae73bd inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a id="a7e9a1b299b4901f8ec5c17a495ae73bd" name="a7e9a1b299b4901f8ec5c17a495ae73bd"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>header_size</b></td></tr>
<tr class="memdesc:a7e9a1b299b4901f8ec5c17a495ae73bd inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bit header size of a link layer PDU <br /></td></tr>
<tr class="separator:a7e9a1b299b4901f8ec5c17a495ae73bd inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bc5bbc6e5ed7f6c1677e568625cf49 inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a id="a61bc5bbc6e5ed7f6c1677e568625cf49" name="a61bc5bbc6e5ed7f6c1677e568625cf49"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>layout_overhead</b></td></tr>
<tr class="memdesc:a61bc5bbc6e5ed7f6c1677e568625cf49 inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">addition layout overhead introduced by the applied layout <br /></td></tr>
<tr class="separator:a61bc5bbc6e5ed7f6c1677e568625cf49 inherit pub_static_attribs_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html">bluetoe::link_layer::ll_data_pdu_buffer&lt; TransmitSize, ReceiveSize, scheduled_radio&lt; TransmitSize, ReceiveSize, CallBack &gt; &gt;</a></td></tr>
<tr class="memitem:a3f1c9d436f59be1c3342eebd81eea419 inherit pub_types_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a3f1c9d436f59be1c3342eebd81eea419">layout</a> = typename <a class="el" href="structbluetoe_1_1link__layer_1_1pdu__layout__by__radio.html">pdu_layout_by_radio</a>&lt; <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt; &gt;::pdu_layout</td></tr>
<tr class="memdesc:a3f1c9d436f59be1c3342eebd81eea419 inherit pub_types_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">layout to be applied to each PDU.  <br /></td></tr>
<tr class="separator:a3f1c9d436f59be1c3342eebd81eea419 inherit pub_types_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html">bluetoe::link_layer::ll_data_pdu_buffer&lt; TransmitSize, ReceiveSize, scheduled_radio&lt; TransmitSize, ReceiveSize, CallBack &gt; &gt;</a></td></tr>
<tr class="memitem:a63c717dafa43b9d4854a01f668d15309 inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbluetoe_1_1link__layer_1_1read__buffer.html">read_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a63c717dafa43b9d4854a01f668d15309">allocate_receive_buffer</a> () const</td></tr>
<tr class="memdesc:a63c717dafa43b9d4854a01f668d15309 inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a buffer for the next PDU to be received.  <br /></td></tr>
<tr class="separator:a63c717dafa43b9d4854a01f668d15309 inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb04733d8c033531f8d1b62f8da0db14 inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbluetoe_1_1link__layer_1_1write__buffer.html">write_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#abb04733d8c033531f8d1b62f8da0db14">received</a> (<a class="el" href="structbluetoe_1_1link__layer_1_1read__buffer.html">read_buffer</a>)</td></tr>
<tr class="memdesc:abb04733d8c033531f8d1b62f8da0db14 inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called by the scheduled radio when a PDU was received without error.  <br /></td></tr>
<tr class="separator:abb04733d8c033531f8d1b62f8da0db14 inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e246612e94bcce12663282ef3b1003d inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbluetoe_1_1link__layer_1_1write__buffer.html">write_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a1e246612e94bcce12663282ef3b1003d">acknowledge</a> (<a class="el" href="structbluetoe_1_1link__layer_1_1read__buffer.html">read_buffer</a>)</td></tr>
<tr class="memdesc:a1e246612e94bcce12663282ef3b1003d inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called, instead of <a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#abb04733d8c033531f8d1b62f8da0db14" title="This function will be called by the scheduled radio when a PDU was received without error.">received()</a>, when the CRC of a received PDU is ok, but the MIC is not ok.  <br /></td></tr>
<tr class="separator:a1e246612e94bcce12663282ef3b1003d inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ee4e7e38d80c613d53cfdd1c58b37c inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbluetoe_1_1link__layer_1_1write__buffer.html">write_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html#a88ee4e7e38d80c613d53cfdd1c58b37c">next_transmit</a> ()</td></tr>
<tr class="memdesc:a88ee4e7e38d80c613d53cfdd1c58b37c inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the next PDU to be transmitted  <br /></td></tr>
<tr class="separator:a88ee4e7e38d80c613d53cfdd1c58b37c inherit pro_methods_classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack&gt;<br />
class bluetoe::link_layer::scheduled_radio&lt; TransmitSize, ReceiveSize, CallBack &gt;</div><p>Type responsible for radio I/O and timing. </p>
<p>The API provides a set of scheduling functions, to schedule advertising or to schedule connection events. All scheduling functions take a point in time to switch on the receiver / transmitter and to transmit and to receive. This points are defined as relative offsets to a previous point in time T0. The first T0 is defined by the return of the constructor. After that, every scheduling function have to define what the next T0 is, that the next functions relative point in time, is based on.</p>
<p>TransmitSize and ReceiveSize is the size of buffer used for receiving and transmitting. This might not make sense for all implementations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acaba4a41d5452cb8e33e209b3e7dde4b" name="acaba4a41d5452cb8e33e209b3e7dde4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaba4a41d5452cb8e33e209b3e7dde4b">&#9670;&#160;</a></span>scheduled_radio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::scheduled_radio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>initializes the hardware and defines the first time point as anker for the next call to a scheduling function. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aed7ff277ad07969c5387fe7524367bb6" name="aed7ff277ad07969c5387fe7524367bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7ff277ad07969c5387fe7524367bb6">&#9670;&#160;</a></span>connection_request_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::connection_request_filter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept connection requests only from devices within the white list. </p>
<p>If the property is set to true, only connection requests from from devices that are in the white list, should be answered. If the property is set to false, all connection requests should be answered.</p>
<p>The default value of the is property is false.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#aed7ff277ad07969c5387fe7524367bb6" title="Accept connection requests only from devices within the white list.">connection_request_filter()</a> == b </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#aed7ff277ad07969c5387fe7524367bb6" title="Accept connection requests only from devices within the white list.">connection_request_filter()</a> </dd></dl>

</div>
</div>
<a id="ac252a72ef11c7512ec918764d25c81ec" name="ac252a72ef11c7512ec918764d25c81ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac252a72ef11c7512ec918764d25c81ec">&#9670;&#160;</a></span>disarm_connection_event()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, <a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a> &gt; <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::disarm_connection_event </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tries to stop a scheduled connection event </p>
<p>The function tries to stop the scheduled connection event if it is not already running, already in the past or too close to happen to be canceled.</p>
<p>If the function was able to stop the connection event, it will return true and the current time from the last anchor plus some margin that is used by <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#af30836f45d87614c8d0b30c08c067b73" title="schedules a connection event">schedule_connection_event()</a> to make sure, that the connection event can be setup before reaching the start time.</p>
<p>The support for this function is optional. If a <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html" title="Type responsible for radio I/O and timing.">scheduled_radio</a> implementation does not implement this function, there will be no support for the peripheral latency option: <a class="el" href="peripheral__latency_8hpp.html#af9e113f54f89801374ca8a52463daa72af44f5f5e97e1a07a7b838ab68d23e26f" title="listen at the very next connection event if bluetoe has an available PDU for sending.">peripheral_latency::listen_if_pending_transmit_data</a> </p>

</div>
</div>
<a id="a2d3f65c5438fda40cc43054a55a180ea" name="a2d3f65c5438fda40cc43054a55a180ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3f65c5438fda40cc43054a55a180ea">&#9670;&#160;</a></span>radio_add_to_white_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::radio_add_to_white_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbluetoe_1_1link__layer_1_1device__address.html">device_address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add the given address to the white list. </p>
<p>Function will return true, if it was possible to add the address to the white list or if the address was already in the white list. If there was not enough room to add the address to the white list, the function returns false. </p>

</div>
</div>
<a id="ae6202ff7f79e51402383ff6290f30677" name="ae6202ff7f79e51402383ff6290f30677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6202ff7f79e51402383ff6290f30677">&#9670;&#160;</a></span>radio_remove_from_white_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::radio_remove_from_white_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbluetoe_1_1link__layer_1_1device__address.html">device_address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove the given address from the white list </p>
<p>The function returns true, if the address was in the list. </p><dl class="section post"><dt>Postcondition</dt><dd>addr is not in the white list. </dd></dl>

</div>
</div>
<a id="abd4fd25ab8ea1ff8f4eacdba75eda520" name="abd4fd25ab8ea1ff8f4eacdba75eda520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4fd25ab8ea1ff8f4eacdba75eda520">&#9670;&#160;</a></span>radio_scan_request_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::radio_scan_request_filter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept scan requests only from devices within the white list. </p>
<p>If the property is set to true, only scan requests from from devices that are in the white list, should be answered. If the property is set to false, all scan requests should be answered.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#abd4fd25ab8ea1ff8f4eacdba75eda520" title="Accept scan requests only from devices within the white list.">radio_scan_request_filter()</a> == b </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#abd4fd25ab8ea1ff8f4eacdba75eda520" title="Accept scan requests only from devices within the white list.">radio_scan_request_filter()</a> </dd></dl>

</div>
</div>
<a id="a7d8cf474398a43df21d714de449e17ec" name="a7d8cf474398a43df21d714de449e17ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8cf474398a43df21d714de449e17ec">&#9670;&#160;</a></span>request_event_cancelation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::request_event_cancelation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>forces the call of CallBack::try_event_cancelation() from the context of the <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a17adbfc6e6022ac5f04aa3fe26b4d85a" title="allocates the CPU to the scheduled_radio">run()</a> function </p>
<p>The function queues the request until control is passed back to <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a17adbfc6e6022ac5f04aa3fe26b4d85a" title="allocates the CPU to the scheduled_radio">run()</a>.</p>
<p>The function is intended to be used from interrupt handler to synchronize with the main thread. </p>

</div>
</div>
<a id="a17adbfc6e6022ac5f04aa3fe26b4d85a" name="a17adbfc6e6022ac5f04aa3fe26b4d85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17adbfc6e6022ac5f04aa3fe26b4d85a">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates the CPU to the <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html" title="Type responsible for radio I/O and timing.">scheduled_radio</a> </p>
<p>All callbacks given by the CallBack parameter are called from within this CPU context. The function will return from time to time, when an external event happed. It's up to concrete implementations to identify and to define situations where the CPU should be released back to the calling application. </p>

</div>
</div>
<a id="af7e6ef1abf22e324765a0dfd245a6ed2" name="af7e6ef1abf22e324765a0dfd245a6ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e6ef1abf22e324765a0dfd245a6ed2">&#9670;&#160;</a></span>schedule_advertisment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::schedule_advertisment </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbluetoe_1_1link__layer_1_1write__buffer.html">bluetoe::link_layer::write_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>advertising_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbluetoe_1_1link__layer_1_1write__buffer.html">bluetoe::link_layer::write_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>response_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a>&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbluetoe_1_1link__layer_1_1read__buffer.html">bluetoe::link_layer::read_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>receive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>schedules for transmission of advertising data and starts to receive 150Âµs later </p>
<p>The function will return immediately. Depending on whether a response is received or the receiving times out, CallBack::adv_received() or CallBack::adv_timeout() is called. In both cases, every following call to a scheduling function is based on the time, the transmission was scheduled. So the new T0 = T0 + when. In case of a CRC error, CallBack::adv_timeout() will be called immediately.</p>
<p>White list filtering is applied by calling CallBack::is_scan_request_in_filter().</p>
<p>This function is intended to be used for sending advertising PDUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>channel to transmit and to receive on </td></tr>
    <tr><td class="paramname">advertising_data</td><td>the advertising data to be send out. </td></tr>
    <tr><td class="paramname">response_data</td><td>the response data used to reply to a scan request, in case the request was in the white list. </td></tr>
    <tr><td class="paramname">when</td><td>point in time, when the first bit of data should be started to be transmitted </td></tr>
    <tr><td class="paramname">receive</td><td>buffer where the radio will copy the received data, before calling Callback::adv_receive(). This buffer have to have at least room for two bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af30836f45d87614c8d0b30c08c067b73" name="af30836f45d87614c8d0b30c08c067b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30836f45d87614c8d0b30c08c067b73">&#9670;&#160;</a></span>schedule_connection_event()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a> <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::schedule_connection_event </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a>&#160;</td>
          <td class="paramname"><em>start_receive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a>&#160;</td>
          <td class="paramname"><em>end_receive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a>&#160;</td>
          <td class="paramname"><em>connection_interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>schedules a connection event </p>
<p>The function will return immediately and schedule the receiver to start at start_receive.</p>
<p>CallBack::timeout() is called when between start_receive and end_receive no valid pdu is received. The new T0 is then the old T0.</p>
<p>CallBack::end_event(connection_event_event evts) is called when the connection event is over. The evts object passed to the end_event() callback will give some details about what happend in that connection event. The new T0 is the time point where the first PDU was received from the central.</p>
<p>In any case is one (and only one) of the callbacks called (timeout(), end_event()), unless the connection event is disarmed prior, by a call to <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#ac252a72ef11c7512ec918764d25c81ec" title="tries to stop a scheduled connection event">disarm_connection_event()</a>. The context of the callback call is <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a17adbfc6e6022ac5f04aa3fe26b4d85a" title="allocates the CPU to the scheduled_radio">run()</a>.</p>
<p>Data to be transmitted and received is passed by the inherited <a class="el" href="classbluetoe_1_1link__layer_1_1ll__data__pdu__buffer.html" title="ring buffers for ingoing and outgoing LL Data PDUs">ll_data_pdu_buffer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the distance from now to start_receive. If the scheduled event is already in the past, the function will return delta_time() and the timeout() callback will be called. </dd></dl>

</div>
</div>
<a id="ab06f311e5b863235bbffe431c9236dc0" name="ab06f311e5b863235bbffe431c9236dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06f311e5b863235bbffe431c9236dc0">&#9670;&#160;</a></span>schedule_synchronized_user_timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::schedule_synchronized_user_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbluetoe_1_1link__layer_1_1delta__time.html">bluetoe::link_layer::delta_time</a>&#160;</td>
          <td class="paramname"><em>max_cb_runtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets up a timer </p>
<p>The timeout is based on the connects last anchor. Which then means, that there has to be a connection and that the anchor will not move, if there was a timeout while waiting for the next connection event.</p>
<p>Calls CallBack::user_timer( bool anchor_moved ) from an unspecified CPU context. anchor_moved is set to true, if the anchor moved inbetween setting up the timer and the timer callback beeing called. </p>

</div>
</div>
<a id="a02bd3a35173bb9ea31b295fbfd2a3823" name="a02bd3a35173bb9ea31b295fbfd2a3823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bd3a35173bb9ea31b295fbfd2a3823">&#9670;&#160;</a></span>set_access_address_and_crc_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::set_access_address_and_crc_init </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>access_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>crc_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the access address initial CRC value for transmitted and received PDU </p>
<p>The values should be changed, when there is no outstanding scheduled transmission or receiving. The values will be applied with the next call to <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#af7e6ef1abf22e324765a0dfd245a6ed2" title="schedules for transmission of advertising data and starts to receive 150Âµs later">schedule_advertisment()</a> or <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#af30836f45d87614c8d0b30c08c067b73" title="schedules a connection event">schedule_connection_event()</a>. </p>

</div>
</div>
<a id="ab9fb3007179d5653da9b360c4762f49f" name="ab9fb3007179d5653da9b360c4762f49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fb3007179d5653da9b360c4762f49f">&#9670;&#160;</a></span>wake_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::wake_up </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>forces the <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html#a17adbfc6e6022ac5f04aa3fe26b4d85a" title="allocates the CPU to the scheduled_radio">run()</a> function to return at least once </p>
<p>The function is intended to be used from interrupt handler to synchronize with the main thread. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9bcf918b88aceffc880ce2049ede5947" name="a9bcf918b88aceffc880ce2049ede5947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcf918b88aceffc880ce2049ede5947">&#9670;&#160;</a></span>radio_maximum_white_list_entries</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::radio_maximum_white_list_entries = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>giving the maximum number of white list entries, the scheduled radio supports by hardware </p>
<p>Only if this value is not zero, the radio have to implement the white list related functions. </p>

</div>
</div>
<a id="a05028ea1473d2778024d1e7d155504ad" name="a05028ea1473d2778024d1e7d155504ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05028ea1473d2778024d1e7d155504ad">&#9670;&#160;</a></span>radio_package_overhead</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TransmitSize, std::size_t ReceiveSize, typename CallBack &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classbluetoe_1_1link__layer_1_1scheduled__radio.html">bluetoe::link_layer::scheduled_radio</a>&lt; TransmitSize, ReceiveSize, CallBack &gt;::radio_package_overhead = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a number of bytes that are additional required by the hardware to handle an over the air package/PDU. </p>
<p>This number includes every byte that have to stored in a package to meet the requirments of the hardware, that is not part of the received / transmitted PDU (CRC, preamble etc.). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bluetoe/link_layer/<a class="el" href="scheduled__radio_8hpp_source.html">scheduled_radio.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 21 2023 10:13:56 for BlueToe by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
