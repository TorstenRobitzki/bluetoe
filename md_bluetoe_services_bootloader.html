<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>BlueToe: bootloader</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueToe
   </div>
   <div id="projectbrief">an alternative GATT/BLE implementation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">bootloader </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Bootloader-Protocol"></a>
Bootloader-Protocol</h1>
<h1>GATT </h1>
<p>The Bootloader is one service containing three characteristics. The UUID of the service is 7D295F4D-2850-4F57-B595-837F5753F8A9. The Control Point characteristic receives commands and requests and sends responds by ATT notifications. The UUID of the Control Point characeteristic is 7D295F4D-2850-4F57-B595-837F5753F8A9. The Data characteristic is used to receive data. The UUID of the Data characteristic is 7D295F4D-2850-4F57-B595-837F5753F8AA. The Progress characetistic is used to give feedback about the used buffer sizes. The UUID of the Progress characteristic is 7D295F4D-2850-4F57-B595-837F5753F8AB.</p>
<p>The characteristics has following properties:</p>
<table class="doxtable">
<tr>
<th>Characteristic </th><th>Properties </th><th>UUID  </th></tr>
<tr>
<td>Control Point </td><td>Write, Notify </td><td>7D295F4D-2850-4F57-B595-837F5753F8A9 </td></tr>
<tr>
<td>Data </td><td>Write </td><td>7D295F4D-2850-4F57-B595-837F5753F8AA </td></tr>
<tr>
<td>Progress </td><td>Notify </td><td>7D295F4D-2850-4F57-B595-837F5753F8AB </td></tr>
</table>
<h1>Procedures </h1>
<p>The bootloader implements following procedures:</p>
<table class="doxtable">
<tr>
<th>Procedure </th><th>Description </th><th align="right">opcode </th><th align="right">expected response code  </th></tr>
<tr>
<td>Get Version </td><td>Read a version string from the user handler </td><td align="right">0 </td><td align="right">0 </td></tr>
<tr>
<td>Get CRC </td><td>Calculate crc over specific area </td><td align="right">1 </td><td align="right">1 </td></tr>
<tr>
<td>Get Sizes </td><td>Returns maschine specific values </td><td align="right">2 </td><td align="right">2 </td></tr>
<tr>
<td>Start Flash </td><td>Start to flash a memory region </td><td align="right">3 </td><td align="right">3 </td></tr>
<tr>
<td>Stop Flash </td><td>Stop to flash a memory region </td><td align="right">4 </td><td align="right">4 </td></tr>
<tr>
<td>Flush </td><td>Flush written data to flash memory </td><td align="right">5 </td><td align="right">5 </td></tr>
<tr>
<td>Start </td><td>Start a programm at a specific address </td><td align="right">6 </td><td align="right">n/a </td></tr>
<tr>
<td>Reset </td><td>Start a programm at a specific address </td><td align="right">7 </td><td align="right">n/a </td></tr>
</table>
<p>A client starts a procedure by sending an ATT Writing Request with the opcode to the Control Point, followed by the parameters that are required for the procedure. If the procedure starts successfully, the Bootloader will response with an ATT Write Response. The procedure will end by the reply of the bootloader that is send with an ATT Notification.</p>
<p>If there was something wrong with the start of the Control Point procedure, the bootloader will response immediately with an ATT Error Response and an error code denoting the reason for the failure. If both, bootloader and bootloader client are implemented without error, an ATT Error Response is not expected.</p>
<p>A write to the Control Point will result in either an ATT Error Response, or in an ATT Notification. A Control Point procedure is active as long as a notification is not send out by the bootloader. There should be only one active Control Point procedured at any time. That means a bootloader have to wait for the end of a procedure before starting the next procedure.</p>
<p>All parameters longer than one octet are encoded in little endian.</p>
<h2>Get Version </h2>
<p>The procedure is started by writing the opcode to the Control Point.</p>
<table class="doxtable">
<tr>
<th>Request Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Opcode </td><td align="right">1 </td><td align="right">0 </td></tr>
</table>
<p>The response is an ATT Notification, with the response code, followed by a variable length version string.</p>
<table class="doxtable">
<tr>
<th>Response Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Response Code </td><td align="right">1 </td><td align="right">0 </td></tr>
<tr>
<td>Version String </td><td align="right">variable </td><td align="right">Version </td></tr>
</table>
<h2>Get CRC </h2>
<p>The procedure is started by writing the opcode, followed by the start- and end-address of the range, to the Control Point. The size of addresses depend on the target architectur and can be inquired, using the Get Sizes procedure.</p>
<table class="doxtable">
<tr>
<th>Request Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Opcode </td><td align="right">1 </td><td align="right">1 </td></tr>
<tr>
<td>Start-Address </td><td align="right">sizeof( std::uint8_t* ) </td><td align="right">first byte of the range </td></tr>
<tr>
<td>End-Address </td><td align="right">sizeof( std::uint8_t* ) </td><td align="right">first byte behind the range </td></tr>
</table>
<p>The response is an ATT Notification, containing the response code and the 32 bit checksum.</p>
<table class="doxtable">
<tr>
<th>Response Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Response Code </td><td align="right">1 </td><td align="right">1 </td></tr>
<tr>
<td>Checksum </td><td align="right">4 </td><td align="right">calculated checksum over the given range </td></tr>
</table>
<h3>CRC Algorithm</h3>
<p>The used CRC algorithm should be adler32.</p>
<h2>Get Sizes </h2>
<p>The procedure is started by writing the opcode to the Control Point.</p>
<table class="doxtable">
<tr>
<th>Request Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Opcode </td><td align="right">1 </td><td align="right">2 </td></tr>
</table>
<p>The response is an ATT Notification, containing certain machine dependen values and buffer sizes.</p>
<table class="doxtable">
<tr>
<th>Response Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Response Code </td><td align="right">1 </td><td align="right">2 </td></tr>
<tr>
<td>Address-Size </td><td align="right">1 </td><td align="right">sizeof( std::uint8_t* ) </td></tr>
<tr>
<td>Page-Size </td><td align="right">4 </td><td align="right"> Size of a Page </td></tr>
<tr>
<td>Page Buffers </td><td align="right">4 </td><td align="right">Number of pages the bootloader can buffer </td></tr>
</table>
<p>The Address-Size is what the expression sizeof( std::uint8_t* ) evaluates to in the bootloader. It's used where ever an address have to be communicted between bootloader and bootloader client. The page size is the size of a single flash page. The number of Page Buffers denontes the amount of data the bootloader can store, before the client have to wait for buffers to becode free.</p>
<h2>Start Flash </h2>
<p>The Start Flash Procedure takes an address as the first and only parameter. As the address size of the target plattform is out of the scope of the bootloader implementation, the size is equal to sizeof( std::uint8_t* ) on the bootloaders target device. The address denotes the target address of the memory contents that follows. The start address must be within the flashable ranges of the bootloader.</p>
<table class="doxtable">
<tr>
<th>Request Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Opcode </td><td align="right">1 </td><td align="right">3 </td></tr>
<tr>
<td>Start Address </td><td align="right">sizeof( std::uint8_t* ) </td><td align="right">address of the range to be flashed </td></tr>
</table>
<p>The bootloader will response with a notification that contains the response code, followed by the current ATT MTU size of the connection, the amount of data that can currently be received by the bootloader and a checksum that is calculated over the received address.</p>
<p>The MTU is send for the case, that the clients BLE API does not give access to that values. The knowlage of the value allows a client to write data in packets as big as possible (MTU-3). A client can start to write the data to be flashed directly after the Start Flash procedure was started (even before the ATT Response was received). If the client has no access to the connections MTU size and not received the Control Point procedures response, it should assume an MTU of 23.</p>
<table class="doxtable">
<tr>
<th>Response Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Response Code </td><td align="right">1 </td><td align="right">3 </td></tr>
<tr>
<td>MTU </td><td align="right">1 </td><td align="right">&gt;= 23 </td></tr>
<tr>
<td>Receive Capacity </td><td align="right">4 </td><td align="right">number of byte that can be received </td></tr>
<tr>
<td>Checksum </td><td align="right">4 </td><td align="right"> crc(Start Address) </td></tr>
</table>
<p>The Bootloader is now in flash mode and will receive data and flash it into memory, as long as data is send to the Data characteristic or until a new control point procedure is received. The bootloader will flush data, when the received data reached the end of a page or when the Flush procedure is executed.</p>
<h3>Buffer Management</h3>
<p>The bootloader have to take care that the bootloaders buffers do not overflow. The number of pages and the size of a page have to be known to the bootloader client or have to be inquired, using the Get Sizes procedure. Writing data into the middle of a page buffer will allocate the part of the buffer before the start address too.</p>
<p>The bootloader will send ATT Notifications using the Progress characteristic, to commucate the current free buffer sizes.</p>
<p>When leaving the flash mode by executing an other Control Point procedure, the next procedure will yield an error, if there was unflashed data.</p>
<h3>Writing parts of a page</h3>
<p>To flash just a part of a page, set the start address to the desired start address. The bootloader will fill the used page buffer with the content before the start address with the content of the flash before the start address. This will result in unchanged flash content before the start address.</p>
<p>If the range to be flashed does not end at the end address of a page (addres % page-size != 0), the Flush procedure have to be invoked. The bootloader will fill the page buffer with the content of the flash behind the actual address. This makes sure, the flash gets not changed at the end of the page.</p>
<h2>Stop Flash </h2>
<p>The procedure is started by writing the opcode to the Control Point. The bootloader client should execute the procedure, when it suspects that an error occured to reset the bootloader. Timeouts or checksum errors might be reasons to execute this procedure.</p>
<table class="doxtable">
<tr>
<th>Request Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Opcode </td><td align="right">1 </td><td align="right">4 </td></tr>
</table>
<p>The response is an ATT Notification, with the response code. When the response is received, the</p>
<table class="doxtable">
<tr>
<th>Response Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Response Code </td><td align="right">1 </td><td align="right">4 </td></tr>
</table>
<h2>Flush </h2>
<p>The procedure is started by writing the opcode to the Control Point. The bootloader must be in flash mode, when executing the procedure and there must be data in the last page buffer that was not automatically flashed (because the last bytes where not at the end of a page).</p>
<table class="doxtable">
<tr>
<th>Request Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Opcode </td><td align="right">1 </td><td align="right">5 </td></tr>
</table>
<p>The response is an ATT Notification, with the response code. When the response is received, the</p>
<table class="doxtable">
<tr>
<th>Response Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Response Code </td><td align="right">1 </td><td align="right">5 </td></tr>
</table>
<h2>Start </h2>
<p>The procedure is started by writing the opcode, followed by the start address to the Control Point.</p>
<table class="doxtable">
<tr>
<th>Request Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Opcode </td><td align="right">1 </td><td align="right">6 </td></tr>
<tr>
<td>Start-Address </td><td align="right">sizeof( std::uint8_t* ) </td><td align="right">first byte of the range </td></tr>
</table>
<p>It is not expected that the bootloader will response with a notification, but instead reset the device and branch to the given address.</p>
<h2>Reset </h2>
<p>The procedure is started by writing the opcode to the Control Point.</p>
<table class="doxtable">
<tr>
<th>Request Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Opcode </td><td align="right">1 </td><td align="right">7 </td></tr>
</table>
<p>It is not expected that the bootloader will response with a notification, but instead reset the device.</p>
<h1>Data </h1>
<p>There is no layout for the data to be written. Data should be written with an ATT Write Request. The bootloader client have to make sure, that the bootloader can store the send data, by knowing the bootloaders buffer sizes and by observice Progress notifications. The bootloader should try to utillize the connection as much as possible and should send the data in packages that are at most MTU -3 in size.</p>
<p>The bootloader will response with an ATT Write Response. The client can write additional data before the bootloader response to that write; as long as the underlying link layer can store the requests.</p>
<p>The Bootloader must be in flash mode by executing the Start Flash procedure.</p>
<h1>Progress </h1>
<p>The bootloader will send progress notifications to inform the client about buffers that became free.</p>
<table class="doxtable">
<tr>
<th>Notification Fields </th><th align="right">Length </th><th align="right">Value  </th></tr>
<tr>
<td>Checksum </td><td align="right">4 </td><td align="right">Checksum over Start-Address and all data received since the last Start Flash procedure start </td></tr>
<tr>
<td>Consecutive </td><td align="right">1 </td><td align="right">Consecutive number, that is reseted to 0 with the start of the Start Flash procedure and is incremented with every write to the Data characteristic </td></tr>
<tr>
<td>MTU </td><td align="right">1 </td><td align="right">&gt;= 23 </td></tr>
<tr>
<td>Receive Capacity </td><td align="right">4 </td><td align="right">number of byte that can be received </td></tr>
</table>
<p>The Consecutive number will overrun every 256th write to the Data characteristic. The purpose of the number is to alow the client to align the received values with the packet send. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2016 21:20:58 for BlueToe by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
