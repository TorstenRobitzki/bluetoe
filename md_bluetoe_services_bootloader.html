<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BlueToe: bootloader</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Logo_Bluetoe.svg"/></td>
  <td id="projectalign">
   <div id="projectname">BlueToe
   </div>
   <div id="projectbrief">an alternative GATT/BLE implementation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">bootloader </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Bootloader-Protocol"></a>
Bootloader-Protocol</h1>
<h1><a class="anchor" id="autotoc_md0"></a>
GATT</h1>
<p>The Bootloader is one service containing three characteristics. The UUID of the service is 7D295F4D-2850-4F57-B595-837F5753F8A9. The Control Point characteristic receives commands and requests and sends responds by ATT notifications. The UUID of the Control Point characeteristic is 7D295F4D-2850-4F57-B595-837F5753F8A9. The Data characteristic is used to receive data. The UUID of the Data characteristic is 7D295F4D-2850-4F57-B595-837F5753F8AA. The Progress characetistic is used to give feedback about the used buffer sizes. The UUID of the Progress characteristic is 7D295F4D-2850-4F57-B595-837F5753F8AB.</p>
<p>The characteristics has following properties:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Characteristic   </th><th class="markdownTableHeadNone">Properties   </th><th class="markdownTableHeadNone">UUID    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Control Point   </td><td class="markdownTableBodyNone">Write, Write Without Response, Notify   </td><td class="markdownTableBodyNone">7D295F4D-2850-4F57-B595-837F5753F8A9    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Data   </td><td class="markdownTableBodyNone">Write, Write Without Response, Indication   </td><td class="markdownTableBodyNone">7D295F4D-2850-4F57-B595-837F5753F8AA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Progress   </td><td class="markdownTableBodyNone">Notify   </td><td class="markdownTableBodyNone">7D295F4D-2850-4F57-B595-837F5753F8AB   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md1"></a>
Procedures</h1>
<p>The bootloader implements following procedures:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Procedure   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadRight">opcode   </th><th class="markdownTableHeadRight">expected response code    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Get Version   </td><td class="markdownTableBodyNone">Read a version string from the user handler   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Get CRC   </td><td class="markdownTableBodyNone">Calculate crc over specific area   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Get Sizes   </td><td class="markdownTableBodyNone">Returns maschine specific values   </td><td class="markdownTableBodyRight">2   </td><td class="markdownTableBodyRight">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Start Flash   </td><td class="markdownTableBodyNone">Start to flash a memory region   </td><td class="markdownTableBodyRight">3   </td><td class="markdownTableBodyRight">3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Stop Flash   </td><td class="markdownTableBodyNone">Stop to flash a memory region   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">4    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Flush   </td><td class="markdownTableBodyNone">Flush written data to flash memory   </td><td class="markdownTableBodyRight">5   </td><td class="markdownTableBodyRight">5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Start   </td><td class="markdownTableBodyNone">Start a programm at a specific address   </td><td class="markdownTableBodyRight">6   </td><td class="markdownTableBodyRight">n/a    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Reset   </td><td class="markdownTableBodyNone">Resets the bootloader   </td><td class="markdownTableBodyRight">7   </td><td class="markdownTableBodyRight">n/a    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Read   </td><td class="markdownTableBodyNone">Read a memory range from the device   </td><td class="markdownTableBodyRight">8   </td><td class="markdownTableBodyRight">8   </td></tr>
</table>
<p>A client starts a procedure by sending an ATT Writing Request with the opcode to the Control Point, followed by the parameters that are required for the procedure. If the procedure starts successfully, the Bootloader will response with an ATT Write Response. The procedure will end by the reply of the bootloader that is send with an ATT Notification.</p>
<p>If there was something wrong with the start of the Control Point procedure, the bootloader will response immediately with an ATT Error Response and an error code denoting the reason for the failure. If both, bootloader and bootloader client are implemented without error, an ATT Error Response is not expected.</p>
<p>A write to the Control Point will result in either an ATT Error Response, or in an ATT Notification. A Control Point procedure is active as long as a notification is not send out by the bootloader. There should be only one active Control Point procedured at any time. That means a bootloader client has to wait for the end of a procedure before starting the next procedure.</p>
<p>All parameters longer than one octet are encoded in little endian.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Get Version</h2>
<p>The procedure is started by writing the opcode to the Control Point.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Request Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">0   </td></tr>
</table>
<p>The response is an ATT Notification, with the response code, followed by a variable length version string.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Response Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Response Code   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Version String   </td><td class="markdownTableBodyRight">variable   </td><td class="markdownTableBodyRight">Version   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md3"></a>
Get CRC</h2>
<p>The procedure is started by writing the opcode, followed by the start- and end-address of the range, to the Control Point. The size of addresses depend on the target architectur and can be inquired, using the Get Sizes procedure.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Request Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Start-Address   </td><td class="markdownTableBodyRight">sizeof( std::uint8_t* )   </td><td class="markdownTableBodyRight">first byte of the range    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">End-Address   </td><td class="markdownTableBodyRight">sizeof( std::uint8_t* )   </td><td class="markdownTableBodyRight">first byte behind the range   </td></tr>
</table>
<p>The response is an ATT Notification, containing the response code and the 32 bit checksum.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Response Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Response Code   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Checksum   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">calculated checksum over the given range   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md4"></a>
CRC Algorithm</h3>
<p>The used CRC algorithm should be adler32.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Get Sizes</h2>
<p>The procedure is started by writing the opcode to the Control Point.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Request Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">2   </td></tr>
</table>
<p>The response is an ATT Notification, containing certain machine dependen values and buffer sizes.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Response Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Response Code   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Address-Size   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">sizeof( std::uint8_t* )    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Page-Size   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight"> Size of a Page    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Page Buffers   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">Number of pages the bootloader can buffer   </td></tr>
</table>
<p>The Address-Size is what the expression sizeof( std::uint8_t* ) evaluates to in the bootloader. It's used where ever an address have to be communicted between bootloader and bootloader client. The page size is the size of a single flash page. The number of Page Buffers denontes the amount of data the bootloader can store, before the client have to wait for buffers to become free.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Start Flash</h2>
<p>The Start Flash Procedure takes an address as the first and only parameter. As the address size of the target plattform is out of the scope of the bootloader implementation, the size is equal to sizeof( std::uint8_t* ) on the bootloaders target device. The address denotes the target address of the memory contents that follows. The start address must be within the flashable ranges of the bootloader.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Request Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Start Address   </td><td class="markdownTableBodyRight">sizeof( std::uint8_t* )   </td><td class="markdownTableBodyRight">address of the range to be flashed   </td></tr>
</table>
<p>The bootloader will response with a notification that contains the response code, followed by the current ATT MTU size of the connection and a checksum that is calculated over the received address.</p>
<p>The MTU is send for the case, that the clients BLE API does not give access to that values. The knowlage of the value allows a client to write data in packets as big as possible (MTU-3). A client can start to write the data to be flashed directly after the Start Flash procedure was started (even before the ATT Response was received). If the client has no access to the connections MTU size and not received the Control Point procedures response, it should assume an MTU of 23.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Response Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Response Code   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MTU   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">&gt;= 23    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Checksum   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight"> crc(Start Address)   </td></tr>
</table>
<p>The Bootloader is now in flash mode and will receive data and flash it into memory, as long as data is send to the Data characteristic or until a new control point procedure is received. The bootloader will flush data, when the received data reached the end of a page or when the Flush procedure is executed. A bootloader client shall not force a flush of data (neither implicit nor explicit) before it received the CRC of the start address to make sure, that the bootloader understood the start address correct.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Buffer Management</h3>
<p>The bootloader client has to take care that the bootloaders buffers do not overflow. The number of pages and the size of a page have to be known to the bootloader client or have to be inquired, using the Get Sizes procedure. Writing data into the middle of a page buffer will allocate the part of the buffer before the start address too.</p>
<p>The bootloader will send ATT Notifications using the Progress characteristic, to commucate the current free buffer sizes.</p>
<p>When leaving the flash mode by executing an other Control Point procedure, the next procedure will yield an error, if there was unflashed data.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Writing parts of a page</h3>
<p>To flash just a part of a page, set the start address to the desired start address. The bootloader will fill the used page buffer with the content before the start address with the content of the flash before the start address. This will result in unchanged flash content before the start address.</p>
<p>If the range to be flashed does not end at the end address of a page (addres % page-size != 0), the Flush procedure have to be invoked. The bootloader will fill the page buffer with the content of the flash behind the actual address. This makes sure, the flash gets not changed at the end of the page.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Stop Flash</h2>
<p>The procedure is started by writing the opcode to the Control Point. The bootloader client should execute the procedure, when it suspects that an error occured to reset the bootloader. Timeouts or checksum errors might be reasons to execute this procedure.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Request Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">4   </td></tr>
</table>
<p>The response is an ATT Notification, with the response code. When the response is received, the</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Response Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Response Code   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">4   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md10"></a>
Flush</h2>
<p>The procedure is started by writing the opcode to the Control Point. The bootloader must be in flash mode, when executing the procedure and there must be data in the last page buffer that was not automatically flashed (because the last bytes where not at the end of a page). After executing the Flush procedure, the bootloader leaves the flash mode.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Request Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">5   </td></tr>
</table>
<p>The response is an ATT Notification, with the response code. When the response is received, the</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Response Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Response Code   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Checksum   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">Checksum over Start-Address and all data received since the last Start Flash procedure start    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Consecutive   </td><td class="markdownTableBodyRight">2   </td><td class="markdownTableBodyRight">Consecutive number, that is reseted to 0 with the start of the Start Flash procedure and is incremented after a block became free   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md11"></a>
Start</h2>
<p>The procedure is started by writing the opcode, followed by the start address to the Control Point.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Request Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Start-Address   </td><td class="markdownTableBodyRight">sizeof( std::uint8_t* )   </td><td class="markdownTableBodyRight">first byte of the range   </td></tr>
</table>
<p>It is not expected that the bootloader will response with a notification, but instead reset the device and branch to the given address.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Reset</h2>
<p>The procedure is started by writing the opcode to the Control Point.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Request Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">7   </td></tr>
</table>
<p>It is not expected that the bootloader will response with a notification, but instead reset the device.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Read</h2>
<p>The Read Procedure is started by writing the Start opcode, followed by start and end address of the range to be read, to the Control Point.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Request Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Start-Address   </td><td class="markdownTableBodyRight">sizeof( std::uint8_t* )   </td><td class="markdownTableBodyRight">address of the range to be read    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">End-Address   </td><td class="markdownTableBodyRight">sizeof( std::uint8_t* )   </td><td class="markdownTableBodyRight">first byte behind the range to be read   </td></tr>
</table>
<p>The Bootloader will send all the requested data in up to MTU - 3 large chunks by indicating them to the Data characteristic. After all data was send, the bootloader response with a notification of the Control Point with a Read response.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Response Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Response Code   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Checksum   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight"> Checksum over Start-Address and all data received    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error Code   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">Reason, why reading from the device failed   </td></tr>
</table>
<p>If reading from the device fails, the bootloader respond by notifying a Read response with an appropriate Error Code field value. An error can be notified every time while the read procedure is running.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Data</h1>
<p>There is no layout for the data to be written. Data should be written with an ATT Write Request. The bootloader client have to make sure, that the bootloader can store the send data, by knowing the bootloaders buffer sizes and by observice Progress notifications. The bootloader should try to utillize the connection as much as possible and should send the data in packages that are at most MTU -3 in size.</p>
<p>The bootloader will response with an ATT Write Response.</p>
<p>The Bootloader must be in flash mode by executing the Start Flash procedure.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Progress</h1>
<p>The bootloader will send progress notifications to inform the client about buffers that became free.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Notification Fields   </th><th class="markdownTableHeadRight">Length   </th><th class="markdownTableHeadRight">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Checksum   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">Checksum over Start-Address and all data received since the last Start Flash procedure start    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Consecutive   </td><td class="markdownTableBodyRight">2   </td><td class="markdownTableBodyRight">Consecutive number, that is reseted to 0 with the start of the Start Flash procedure and is incremented after a block became free    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MTU   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">&gt;= 23   </td></tr>
</table>
<p>The Consecutive number will overrun with every 65536th freed block. The purpose of the number is to alow the client to align the received values with the blocks send and the checksum that was calculated for that block. The bootloader shall notify a progress PDU when a buffer becomes free. A client can expect that the data of the freed buffer was flashed successfully.</p>
<p>A client that received a progress PDU shall start to send more data.</p>
<p>A client can use the checksum to detect transmission errors, but the client is not required to do so.</p>
<p>If the data that was send with the write to the Data characteristic (identified by the consecutive number), spans over the end of the current block, the checksum is calculated only till the end of the block.</p>
<p>A client should write the next data to the Data characteristic with a length of MTU -3 at max. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 21 2023 10:13:56 for BlueToe by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
